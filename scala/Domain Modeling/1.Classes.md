## 基本用法
scala中一般不需要单独写构造函数，参数列表和类体的顶层作用于中定义的变量都会被自动注册为属性。

```scala
//REPL
scala> class Person(val name:String,var age:Int){
     |  println(s"Hello,${name}!")
     |  val birthYear:Int = 2025-age
     |  println(s"You are born in ${birthYear}")
     |  def celebrateBirthday():Unit={
     |      age+=1
     |      println(s"Happy birthday ${name}. You are now ${age} years old!")
     |  }
     | }
class Person

scala> var Alice:Person = new Person(name="Alice",age=22)
Hello,Alice!
You are born in 2003
var Alice: Person = Person@4219a4cc

scala> Alice.birthYear
val res4: Int = 2003
```

如果某些属性的计算比较复杂，不希望把中间变量注册在属性中，则可以把表达式用`{}`包裹在内层作用域内。
scala也可以在类的参数列表中给出默认值。
```scala
//REPL
scala> class Circle(val radius:Double = 1){
     |  val area={val rSquare=radius*radius;3.14*rSquare}
     |  }
class Circle

scala> val c1=new Circle(2.5)
val c1: Circle = Circle@870413c

scala> c1.area
val res1: Double = 19.625

scala> c1.rSquare
          ^
       error: value rSquare is not a member of Circle
```

## 辅助构造函数(Auxiliary constructors) 

类定义中参数列表内的是主构造函数，类体内还可以定义多个辅助构造函数。

在实例化时可以选择使用哪一个构造函数来进行实例化。

所有的辅助构造函数在第一行必须调用另一个构造函数（主构造函数或辅助构造函数均可），辅助构造函数可以形成一个调用树，调用树的任意路径最后必须追溯到主构造函数，即主构造函数是调用树的根节点。

所有的构造函数的函数名都是this,具体调用哪一个是由参数列表的参数个数和参数类型决定的，如果一个类中两个构造函数的参数个数以及参数类型都相同，则这个类的定义不能通过编译。

```scala
class Student(val name: String) {
  var _id = -1
  var _age = -1
  def this(name: String, id: Int) = {
    this(name)
    _id = id
  }
  override def toString: String = s"Student(name=$name, id=${_id}, age=${_age})"
}


```

```scala
//REPL
//load Student defination
scala> :load Student.scala
val args: Array[String] = Array()
Loading Student.scala...
class Student

scala> val Zhang=new Student("Zhang San")
val Zhang: Student = Student(name=Zhang San, id=-1, age=-1)

scala> Zhang.name
val res0: String = Zhang San

scala> Zhang._id
val res1: Int = -1

scala> val Li=new Student("Li Si",20)
val Li: Student = Student(name=Li Si, id=20, age=-1)

scala> Li.name
val res4: String = Li Si


scala> Li._id
val res3: Int = 20
```

两个辅助构造方法如果参数列表的参数数量和类型都一样，会触发错误
```scala
class StudentFaulty(val name: String) {
  var _id = -1
  var _age = -1
  def this(name: String, id: Int) = {
    this(name)
    _id = id
  }
  def this(name: String, age: Int) = {
    this(name)
    _age = age
  }
}
```

```scala
//REPL
scala> :load Student.scala
val args: Array[String] = Array()
Loading Student.scala...
class Student

         def this(name: String, age: Int) = {
             ^
Student.scala:8: error: constructor StudentFaulty is defined twice;
         the conflicting constructor StudentFaulty was defined at line 4:7
```

辅助构造函数不能添加新的字段，也就是说不能增加新的属性，只能修改已有的属性。所有辅助构造函数中可能使用到的属性都必须在类体中事先定义并做dummy初始化。

这意味着这些在辅助构造函数中被引入的属性在类体中还必须声明为var。
这并不符合scala的风格习惯，更优雅的做法是使用object的apply函数把辅助构造函数解耦出来([[2.Objects#解耦辅助构造函数]]),或者使用[[5.Case classes]]自动调用apply或unapply。

## 继承
scala是单继承、混入多特质的语言，即子类只能继承自一个父类，但可以混入多个trait.

使用extend关键字继承父类：
```scala
class 子类名 extends 父类名 {
  // 子类定义
}
```

使用extend with混入trait[[3.traits]]
```scala
class 子类 extends 父类 with 特质1 with 特质2 {
  // 实现细节
}
```

示例：
```scala
class Animal {
  def speak(): Unit = println("Some sound")
}

trait Tail {
  def wag(): Unit = println("Tail wagging")
}

class Dog extends Animal with Tail {
  override def speak(): Unit = println("Woof!")
}
```

在实例化时首先执行父类构造器，然后从左到右执行混入特质，最后执行子类主构造器：
```scala
//REPL
scala> class A {println("A")}
class A

scala> trait B {println("B")}
trait B

scala> trait C {println("C")}
trait C

scala> class ASub extends A with B with C {println("ASub")}
class ASub

scala> new ASub
A
B
C
ASub
val res0: ASub = ASub@5020e5ab
```

重写父类或trait中的方法时，如果该方法已经实现方法体，则必须用override关键字声明重写.
```scala
class Animal {
  def sound(): String = "some sound"
}

class Cat extends Animal {
  override def sound(): String = "meow"
}
```

如果方法仅声明(abstract method)，则不必添加override.([[4.Abstract classes]])
ps.抽象方法只能声明在抽象类或trait中
```scala
abstract class Animal {
  def sound(): String
}

class Dog extends Animal {
  def sound(): String = "woof"
}
```

可以使用super调用父类成员
```scala
class Animal {
  def speak(): Unit = println("generic sound")
}

class Dog extends Animal {
  override def speak(): Unit = {
    super.speak()  // 调用父类版本
    println("woof!")
  }
}
```

父类中的private成员子类不能访问，父类的protected成员子类可以访问，但实例化后不能从外部访问。
```scala
scala> class Animal {
     | protected def eat() :Unit = {println("Eating...")}
     | private val secret:String = "a secret"
     | }
class Animal

scala> class Dog extends Animal {
     | def dogEat() = super.eat()
     | }
class Dog

scala> val dog = new Dog
val dog: Dog = Dog@37289e90

scala> dog.dogEat()
Eating...

scala> dog.eat()
           ^
       error: method eat in class Animal cannot be accessed as a member of Dog from class $iw
        Access to protected method eat not permitted because
        enclosing class $iw is not a subclass of
        class Animal where target is defined
        
scala> class Cat extends Animal {
     | def catEat() = super.eat()
     | def catSaySecrets():Unit = println(super.secret)
     | }
       def catSaySecrets():Unit = println(super.secret)
                                                ^
On line 3: error: value secret in class Animal cannot be accessed as a member of Animal from class Cat
```
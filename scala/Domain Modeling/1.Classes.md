## 基本用法
scala中一般不需要单独写构造函数，参数列表和类体的顶层作用于中定义的变量都会被自动注册为属性。

```scala
//REPL
scala> class Person(val name:String,var age:Int){
     |  println(s"Hello,${name}!")
     |  val birthYear:Int = 2025-age
     |  println(s"You are born in ${birthYear}")
     |  def celebrateBirthday():Unit={
     |      age+=1
     |      println(s"Happy birthday ${name}. You are now ${age} years old!")
     |  }
     | }
class Person

scala> var Alice:Person = new Person(name="Alice",age=22)
Hello,Alice!
You are born in 2003
var Alice: Person = Person@4219a4cc

scala> Alice.birthYear
val res4: Int = 2003
```

如果某些属性的计算比较复杂，不希望把中间变量注册在属性中，则可以把表达式用`{}`包裹在内层作用域内。
scala也可以在类的参数列表中给出默认值。
```scala
//REPL
scala> class Circle(val radius:Double = 1){
     |  val area={val rSquare=radius*radius;3.14*rSquare}
     |  }
class Circle

scala> val c1=new Circle(2.5)
val c1: Circle = Circle@870413c

scala> c1.area
val res1: Double = 19.625

scala> c1.rSquare
          ^
       error: value rSquare is not a member of Circle
```

## 辅助构造函数(Auxiliary constructors) 

类定义中参数列表内的是主构造函数，类体内还可以定义多个辅助构造函数。

在实例化时可以选择使用哪一个构造函数来进行实例化。

所有的辅助构造函数在第一行必须调用另一个构造函数（主构造函数或辅助构造函数均可），辅助构造函数可以形成一个调用树，调用树的任意路径最后必须追溯到主构造函数，即主构造函数是调用树的根节点。

所有的构造函数的函数名都是this,具体调用哪一个是由参数列表的参数个数和参数类型决定的，如果一个类中两个构造函数的参数个数以及参数类型都相同，则这个类的定义不能通过编译。

```scala
class Student(val name: String) {
  var _id = -1
  var _age = -1
  def this(name: String, id: Int) = {
    this(name)
    _id = id
  }
  override def toString: String = s"Student(name=$name, id=${_id}, age=${_age})"
}


```

```scala
//REPL
//load Student defination
scala> :load Student.scala
val args: Array[String] = Array()
Loading Student.scala...
class Student

scala> val Zhang=new Student("Zhang San")
val Zhang: Student = Student(name=Zhang San, id=-1, age=-1)

scala> Zhang.name
val res0: String = Zhang San

scala> Zhang._id
val res1: Int = -1

scala> val Li=new Student("Li Si",20)
val Li: Student = Student(name=Li Si, id=20, age=-1)

scala> Li.name
val res4: String = Li Si


scala> Li._id
val res3: Int = 20
```

两个辅助构造方法如果参数列表的参数数量和类型都一样，会触发错误
```scala
class StudentFaulty(val name: String) {
  var _id = -1
  var _age = -1
  def this(name: String, id: Int) = {
    this(name)
    _id = id
  }
  def this(name: String, age: Int) = {
    this(name)
    _age = age
  }
}
```

```scala
//REPL
scala> :load Student.scala
val args: Array[String] = Array()
Loading Student.scala...
class Student

         def this(name: String, age: Int) = {
             ^
Student.scala:8: error: constructor StudentFaulty is defined twice;
         the conflicting constructor StudentFaulty was defined at line 4:7
```

辅助构造函数不能添加新的字段，也就是说不能增加新的属性，只能修改已有的属性。所有辅助构造函数中可能使用到的属性都必须在类体中事先定义并做dummy初始化。

这意味着这些在辅助构造函数中被引入的属性在类体中还必须声明为var。
这并不符合scala的风格习惯，更优雅的做法是使用[伴生对象]([[2.Objects#解耦辅助构造函数]])的apply函数把辅助构造函数解耦出来，或者使用[case class]([[5.Case classes]])自动调用apply或unapply。


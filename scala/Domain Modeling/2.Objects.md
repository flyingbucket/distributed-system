Object是一种只能创建一个实例的类（单例对象），当这个实例被引用时才会初始化（懒加载）。
主要用途是把一些常用的method放到一个object的命名空间下，便于管理；也可以用一些object的类变量做一些状态记录（比如全局计数器）。
*有点类似于python staticmethod和dataclass的一个合体*

## 命名空间管理

```scala
object StringUtils { 
	def truncate(s: String, length: Int): String = s.take(length) 
	def containsWhitespace(s: String): Boolean = s.matches(".*\\s.*") 
	def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty 
}
```

调用实例方法
```scala
StringUtils.truncate("Chuck Bartowski", 5) // "Chuck"
```

import导入使用
```scala
import StringUtils._ 
truncate("Chuck Bartowski", 5) // "Chuck" 
containsWhitespace("Sarah Walker") // true 
isNullOrEmpty("John Casey") // false
```
```scala
import StringUtils.{truncate, containsWhitespace} 
truncate("Charles Carmichael", 7) // "Charles" 
containsWhitespace("Captain Awesome") // true 
isNullOrEmpty("Morgan Grimes") // Not found: isNullOrEmpty (error)
```

保存常量
```scala
object MathConstants { 
	val PI = 3.14159 
	val E = 2.71828 
} 

println(MathConstants.PI) // 3.14159
```

## Companion Object（伴生对象）
一个类的Companion Object是和该类具有相同名称的object,该类也成为该object的Companion class

成对的Companion object/class可以互相访问对方的私有变量和方法。

### 定义“static” method

可以把不依赖于实例具体数据的方法解耦出来，放到类的伴生对象中定义，然后在类方法中调用。
类似于python的staticmethod，只不过放到了一个object中定义，而不是放在类体作用域内。

```scala
import scala.math._

class Circle(val radius: Double) {
  def area: Double = Circle.calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

val circle1 = new Circle(5.0)
circle1.area

```

Q:为什么不通过trait来实现 ([[3.traits#trait的抽象接口在类中的实现]])
A:trait中定义的是通用接口，可以被extend到任何类中，但业务逻辑中有一些静态方法仅仅和一个类有关，那么这个方法应该放到伴生对象来定义。
### 解耦辅助构造函数

apply方法是scala给出的一种语法糖，让定义了apply函数的class或object可以像函数一样被调用。
当我调用`Something(...)`时，scala会解析为`Something.apply(...)`
类似于python的`__call__`

```scala
class Doubler:
  def apply(x: Int): Int = x * 2

val d = new Doubler()

println(d(10))   // 调用 d.apply(10)
```

apply方法还可以定义在伴生对象里：
```scala
class Person(val name: String)

object Person:
  def apply(name: String): Person = new Person(name)
```

apply函数可以解决辅助构造函数中必须在类体中将属性声明为var的问题
```scala
class Student(val name: String, val id: Int, val age: Int)

object Student:
  def apply(name: String): Student              = new Student(name, -1, -1)
  def apply(name: String, id: Int): Student     = new Student(name, id, -1)
  def apply(name: String, id: Int, age: Int): Student = new Student(name, id, age)

```
但是使用伴生对象+apply方法的解决方案还是不能修改类的字段，
实际上如果确实需要不同的实例具有不同的字段，**应该直接用继承来解决，而不是折腾辅助构造函数和apply**。

## update
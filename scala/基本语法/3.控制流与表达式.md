## if-else
```scala
if (x < 0) {
 println("negative") 
} else if (x == 0) {
  println("zero") 
} else {
   println("positive") 
}
```

if-else组合在scala中不仅仅是一段流程控制代码，它可以构成一个具有返回值的表达式

```scala
val minValue = if (a<b) a else b
```

```scala 
// REPL behavior
scala> val a:Int = 1
val a: Int = 1

scala> val b:Int = 10
val b: Int = 10

scala> val minValue = if (a<b) a else b
val minValue: Int = 1
```

也正因为if-else语句在scala中是一个表达式，所以我们可以把它当成一个方法的实现体
```scala
def compare(a: Int, b: Int): Int = if (a < b) -1 else if (a == b) 0 else 1
// or
def compare(a:Int,b:Int):Int = {
	if (a<b) -1
	else if (a==b) 0
	else 1
}
```

```scala
// REPL behavior
scala> val a:Int = 1
val a: Int = 1

scala> val b:Int = 10
val b: Int = 10

scala> def compare(a: Int, b: Int): Int = if (a < b) -1 else if (a == b) 0 else 1
def compare(a: Int, b: Int): Int

scala> :past
// Entering paste mode (ctrl-D to finish)

def compare(a:Int,b:Int):Int = {
    if (a<b) -1
    else if (a==b) 0
    else 1
}

// Exiting paste mode... now interpreting.
def compare(a: Int, b: Int): Int

scala> val sign = compare(a,b)
val sign: Int = -1
```

*所有表达式都有返回值，这种风格成为expression-oriented-programming （EOP）。没有返回值的代码块成为statement,它们只有**副作用(side effects)** 比如向终端打印输出、写入文件等等。*

**scala 鼓励使用expression而非statement**

## for-loop

### side effects
for loop可以遍历一个scala的collection、Range
```scala
//REPL
scala> val ints=Seq(1,2,3,4,5)
val ints: Seq[Int] = List(1, 2, 3, 4, 5)

scala> for (i<-ints) println(i)
1
2
3
4
5
```

多行形式
```scala
for (i <- ints) {
	val x = i * 2 
	println(s"i = $i, x = $x") 
}
```

scala的多层循环不必使用多个循环体嵌套，可以用一个for循环加多个生成子的模式

```scala
for { 
	i <- 1 to 2 
	j <- 'a' to 'b' 
	k <- 1 to 10 by 5 
} { 
	println(s"i = $i, j = $j, k = $k") 
}
```

卫语句可以放在循环体之前、与生成子并列；使用这种语法糖，scala会在运行时使用withFilter、map/flatMap做反糖，在进入循环体之前完成筛选，提高运行效率效率。

```scala
for { 
	i <- 1 to 5 
	if i % 2 == 0  //guard
} { 
	println(i) 
}
```

### for experssion
在循环体中用yield关键字修饰一个表达式，这个表达式的值就会被for experssion返回

```scala
//REPL behavior
scala> val list = for (i<-10 to 12) yield i*2
val list: IndexedSeq[Int] = Vector(20, 22, 24)
```

`for … yield` 会**遍历**输入，对每个元素应用计算，并把每次 `yield` 的结果**按顺序收集**到一个容器里；等价于一次 `map`。

```scala
scala> val list = (10 to 12).map(i => i * 2)
val list: IndexedSeq[Int] = Vector(20, 22, 24)
```

for experssion同样也可以作为一个方法体

```scala
def between3and10(xs: List[Int]): List[Int] = 
	for { 
		x <- xs 
		if x >= 3 
		if x <= 10 
	} yield x 

val result = between3and10(List(1, 3, 7, 11)) // : List[Int] = List(3, 7)
```

```scala
//REPL behivor
scala> :paste
// Entering paste mode (ctrl-D to finish)

def between3and10(xs: List[Int]): List[Int] =
    for {
        x <- xs
        if x >= 3
        if x <= 10
    } yield x

// Exiting paste mode... now interpreting.
def between3and10(xs: List[Int]): List[Int]

scala> between3and10(List(1,3,5,7,9,11))
val res1: List[Int] = List(3, 5, 7, 9)

scala> val result = between3and10(List(1,3,5,7,9,11))
val result: List[Int] = List(3, 5, 7, 9)
```

## while loops
```scala
var i=1
while (i<10){
	println(i)
	i+=1
}
```

## match

## try-catch-finally


本文整理 Spark 的核心概念与架构设计，按照编程抽象层、运行时架构层、调度执行层和集群部署层四类进行介绍。

---

## 编程抽象层（Programming Abstractions）

### RDD（Resilient Distributed Dataset）
Spark 最基础的分布式数据结构。RDD 是不可变、支持分区化、具备容错机制（通过血统 lineage 追踪）的数据集合。所有 Transformations 都返回新的 RDD。

### DataFrame 与 Dataset
在 RDD 之上的更高级抽象，带有 schema 信息，可进行 Catalyst 优化。DataFrame 是未类型化的表结构，Dataset 是类型安全的强类型结构。

### Transformation
RDD对象的方法，对 RDD 的转换操作，例如 map、filter、flatMap、join 等。Transformation 具有懒执行特性，不会立即计算，而是构建逻辑执行图（DAG）。

### Action
RDD对象的方法，触发真实计算的操作，例如 count、collect、take、saveAsTextFile 等。Action 会启动完整调度流程，最终产生一个 Job。

### DAG（Directed Acyclic Graph）
Spark 根据一系列 Transformation 构建的逻辑执行图。DAG 仅描述计算过程的依赖关系，是逻辑计划（Logical Plan），不包含具体执行资源信息。

---

## 调度执行层（Scheduling Layer）

### Application
完整的一段 Spark 程序。每个 Application 有自己的 Driver 和 Executors。不同应用之间资源独立。

### Job
每个 Action（如 count, collect）会触发一个 Job。一个 Application 可包含多个 Job。

### Stage
Spark 根据 RDD 依赖类型（宽依赖与窄依赖）将 Job 划分成多个 Stage。每个 Stage 内部包含多个Task,Task可以并行执行。

### Task
Spark 最小的调度执行单元。RDD的每个 Partition 会对应一个 Task。Task 会被调度至 Executor 并行运行。

---
## 运行时架构层（Runtime Architecture）

### Driver
运行用户 main() 函数的进程。负责：
- 构建 DAG
- 将 DAG 划分为 Stage
- 向 Cluster Manager 请求资源
- 调度 Task 到 Executors
- 接收执行结果

Driver 是 Spark 应用程序的控制中心。使用saprk-submit提交程序时，deploy-mode选择client(默认),则Driver运行在客户端本机，日志在本地；选择cluster,则Cluster Manager会自爱集群中选择一个worker节点来运行Driver，日志在该worker节点。

### Executor
运行在 Worker 节点上的 JVM 进程，负责：
- 具体执行 Task
- 缓存和存储 RDD Partition 数据
- 执行用户代码

每个 Spark Application 拥有一组独立的 Executors。

### Cluster Manager
管理集群资源的组件。Spark 支持不同的资源管理器：
- Standalone：Spark 内置管理器
- YARN：Hadoop 生态主流 RM
- Kubernetes：容器化环境中的资源管理器

Cluster Manager 负责资源分配，不参与计算。

---

## 集群部署与基础设施层（Cluster Deployment）

### Master（Standalone 模式）
在 Standalone 集群中，Master 负责 Worker 节点的注册、心跳监控和资源分配。相当于集中式的资源管理器。

### Worker Node
集群中的工作节点，负责：
- 启动 Executor 进程
- 持有数据分区
- 执行任务
- 存储 shuffle 数据

Worker 与 Executor 共同完成 Spark 的实际运行。

---
![[cluster-overview.png]]
## Spark 整体架构关系 summary

从用户代码到集群执行的逻辑关系如下：

1. 用户代码通过 Transformation 构造 RDD DAG（逻辑计划）
2. Action 触发执行，生成一个 Job
3. Spark 根据依赖关系将 Job 切分为多个 Stage
4. 每个 Stage 进一步拆分为多个 Task
5. Driver 将 Task 调度到 Executors
6. Executors 在 Worker 节点上执行任务并返回结果
7. 整个过程受 Cluster Manager 调度资源

